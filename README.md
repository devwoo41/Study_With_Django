## 웹사이트 방문

👉 **[WJPYLOVER.pythonanywhere.com/foods/menu](https://WJPYLOVER.pythonanywhere.com/foods/menu)**


---> *All the Sources and references are from Codeit.*

## 학습 내용

#### 프로젝트 구조

- 가장 바깥쪽의 최상위 프로젝트 디렉토리를 'project root'라고 하고 안쪽의 다른 하나의 디렉토리를 'project app'이라고 한다. 이 두개가 이름이 같아 헷갈리기도 하는데 가장 바깥쪽의 디렉토리를 'project root'라고 하고 안쪽은 'project app'이라고 한다.

- manage.py는 django 프로젝트 관리를 위한 명령어를 지원해주고, 앱 생성, 데이터베이스 관련 명령, 개발 서버 실행 등을 담당한다.

- db.sqlite3은 프로젝트에서 관리하는 데이터베이스 파일이다.

- *__init__.py* 가 있어 디렉토리를 하나의 파이썬 패키지로 인식될 수 있는것인데, python 3.3버전 이상부터는 이 파일이 없어도 python 패키지로 인식되기도 하는데, 그래도 적어두는 이유는 *하위버전호환*의 이유에서이다.

- settings.py에서는 시간대 설정, 데이터베이스 설정, 여러 경로 설정 등 django 프로젝트의 전반적인 설정을 담당한다.

- urls.py는 url을 보고 알맞은 페이지로 연결해주는 역할을 한다.

- wsgi.py는 웹 서버와 django가 소통하는데 필요한 일종의 프로토콜을 담당하는 파일이다.

#### Django 앱

- admin.py 파일은 앱을 django 관리자와 연동하기 위해 필요한 설정파일이다. 

- apps.py 파일은 앱에 대한 설정을 넣어두는 파일이다.
- models.py는 django앱에서 사용할 데이터 모델 정의하고 데이터베이스 연동과 관련된 파일이다.

- views.py 파일은 서버에 어떤 요청이 들어왔을때 메인 로직을 처리하는 것과 관련된 파일이다.

- test.py 파일은 앱에 오류가 있는지를 검증하기 위해서 테스트 파일을 작성해주는 파일이다.

- migrations 디렉토리는 데이터베이스의 변경사항 히스토리를 누적해서 저장해두는 공간이다.

- 새로운 앱을 만들고 나면 프로젝트에 새로운 앱이 만들어졌따는 사실을 알리기 위해 INSTALLED_APPS의 리스트안에 새롭게 설치한 앱을 넣어줘야 한다.

#### Reusable app

- 앱은 하나의 기능 단위이고, 프로젝트는 여러 앱을 가질 수 있다. 또 이렇게 생성된 하나의 앱이 여러 프로젝트에서 동시에 사용될 수도 있다. 예컨대, 다른 프로젝트에서 회원가입 기능(회원가입 app)이 필요하다고 했을때, 이전의 프로젝트에서 앱들을 기능단위로 잘 설계해 두었따고 한다면 그 앱을 프로젝트에 그대로 가져다 사용할 수 있다.

- <django의 철학>
```
1. 한가지 앱은 한가지 기능을 하고, 그 기능을 잘 수행해야 한다.
2. 장고 개발자는 프로젝트를 많은 앱으로 구성하는 것을 두려워하면 안 된다.
3. 각각의 앱을 유연하게 작성해야한다.
4. 다른 사람에게 배포가 가능하도록 만들어야 한다.
```

#### 클라이언트와 서버

- 클라이언트는 서비스를 요청하는 쪽으로 웹 브라우저나, 모바일 앱등이 이에 해당한다. 서버는 클라이언트들에게 서비스를 제공하면 서버라고 부른다. 

- 우리가 runserver를 통해서 서버를 실행하면, 가장 먼저 인식하는 파일은 restaurant (프로젝트 앱) 디렉토리 아래의 urls.py 인데, 이 이유는 settings.py 를 보면 ROOT_URLCONF = 'restaurant.urls' 와 같이 명시되어 있기 때문이다.

- url은 네트워크 상의 자원의 위치를 나타내는 문자열이고, domain은 서버를 의미한다.

- Django 에서는 URL 패턴을 항상 트레일링 슬래시(/) 포함으로 작성하는게 원칙이며, 슬래시 없는 요청은 자동으로 슬래시 있는 URL로 리디렉션된다. 링크에서 앞에 슬래시가 있으면 도메인 기준 절대 경로로 이동한다. 그러나, 앞에 슬래시가 없으면 현재 URL 뒤에 붙는 상대 경로로 이동한다.

#### Django 템플릿과 렌더링

- 사용자에게 보여지는 프론트엔드 영역에 글자를 넣거나 하는 경우, 일일이 views.py 내부에 하드코딩을 한다면 가시성이 떨어지고 코드가 지저분하게 된다. Template을 유저에게 보여 줄 수 있도록 변환(redering)을 하면 보여줄 수 있다.

- Template이라는 화면 구성을 담당하는 부분이 Rendering을 통해 HttpResponse 객체로 변환된다.

- render( request, template_name, context=None, content_type=None, status=None, using=None )
```
request에는 데이터를 요청한 요청 객체를 넘겨준다.
template_name은 렌더링에서 사용할 대상 템플릿을 명시한다.
context는 템플릿에 추가할 값들이 들어있는 사전형 인자이다.
context_type은 결과로 만들어 내는 문서의 유형이다.
status는 상태코드이다.
using은 템플릿을 렌더하는 템플릿 엔진을 지정할 수 있는 인자이다.
```

#### Django의 MVT 구조 (MVT 아키텍쳐)

- Model : 모델은 장고의 데이터 구조를 생성해주고 데이터베이스와 소통을 해준다. 강의 테이블에는 강의명, 강의코드, 교수명 등과 학생테이블에는 이름, 학과, 학번등을 저장해야 한다. 

- Template : 템플릿은 웹 사이트의 화면 구성을 담당하는 부분이다. django 템플릿에는 template language를 통해서 동적인 화면을 구성할 수 있다. Template language를 통해서 변화는 세부 요소들을 동적으로 작성할 수 있다.

- View : 로직을 담당하는 부분으로서 Model과 Template을 연결해준다. 요청이 들어왔을때, model을 통해서 데이터를 가져오고 처리된 데이터를 템플릿에 보내준다. 

#### 정적 파일

- 웹 페이지를 렌더링하는 과정에서 필요한 추가적인 파일

- static이라는 별도의 디렉토리를 통해 관리하고 {% load static %}을 통해서 호출해 사용한다.

- 샌드위치 구조로 폴더를 정리하는 이유는, 하나의 프로젝트 내에 여러 앱이 존재하기 때문이다.

#### 템플릿 언어

- 템플릿 변수 : 우리가 지정한 데이터로 변환
{{ 변수명 }} , 이런 형태로 사용하는데 템플릿 변수는 우리가 지정한 데이터로 변환된다.
{{ 변수명.속성 }} , 점 연산자를 통해 템플릿 변수의 내부 속성에 접근한다.

- 템플릿 태그 : 템플릿 작성에 로직을 사용
{% 태그 %} / {{% end태그 %}} , 템플릿 작성에 로직을 적용해준다. 

- 템플릿 필터 : 템플릿 변수를 특정형식으로 변환
{{ 변수명|필터 }}, 템플릿 변수를 특정 필터로 변환할 때 사용한다.

- 템플릿 주석 : 템플릿 언어의 주석처리를 담당
{# 주석 #} , 템플릿 내부의 주석 처리를 해준다.

#### 템플릿 상속

- 장고에서는 여러 앱을 사용해 템플릿이 많이 생기고 겹치게 되는데, 이런 경우 부모 템플릿을 만들어두고 겹치는 부분은 자식 템플릿으로 상속해주는 방식을 사용하게 된다.

#### 동적 웹페이지 (코드를 수정하지 않고도 자동으로 변하는 웹페이지)

- render 함수의 세번째 파라미터를 통해 함숫값을 템플릿에 전달해줄 수 있다.

- 경로변수를 이용한 Dynamic URL로 경로를 깔끔하게 정리할 수 있다.

#### URLConf(urls.py)

- Django에서 URL을 처리하기 위해서는 URLconf모듈 즉 urls.py를 작성해야 한다. 

- URL 처리 순서는 다음과 같다.
```
1. 처음 요청이 들어오면 Django는 맨 처음 사용할 URLConf 모듈을 찾는다. 따로 변경하지 않았다면 프로젝트 앱 내 settings.py의 ROOT_URLCONF 설정을 사용한다.

2. ROOT_URLconf로 정의된 URLConf 모듈을 보고 urlpatterns 리스트 안쪽의 django,urls.path() 함수를 순서대로 실행한다.

3. 요청과 일치하는 URL 패턴이 있다면 django.urls.path() 함수에 따라 view를 호출하거나, 일치하는 URL 패턴 다으의 URL을 하위 URLconf 모듈로 넘긴다.
```

- URL 문자열을 인수로 받으며 경로 변수(Path Converter)를 사용하여 URL의 일부를 view의 인수로 보낼 수 있다.

#### 상태코드 : 요청에 대한 처리 결과를 알려주는 코드
```
1XX : 클라이언트로부터 요청을 받아서 작업중
2XX : 요청에 대한 처리 결과가 정상
3XX : 요청을 완료하기 위해 추가적인 동작이 필요함
4XX : 에러를 의미하는 상태코드
5XX : 서버가 요청을 처리하는 과정에서 문제 발생
```

#### 데이터 모델링 : 데이터를 구성

- 실제 데이터는 데이터베이스에 저장된다. (ex. MySQL, PostgreSQL 등...)

- ORM을 통해 SQL문 없이 파이썬 코드로 데이터베이스와 소통할 수 있다. Django에서는 모델이 ORM기능을 제공해서, 우리가 모델 구조를 정의한 다음 그 구조를 파이썬 코드로 작성하면 그 구조에 맞는 SQL 코드를 자동으로 생성하고 그에 맞게 데이터베이스를 생성해준다.

#### Makemigrations와 migrate

- 파이썬에서 코드를 통해 장고의 모델을 변경하고 나면 변경사항을 저장하고 반영하기 위해서 python manage.py makemigrations -> python manage.py migrate를 통해 반영해주어야 한다.

#### Django의 필드와 옵션

- 필드는 데이터 테이블에서의 열(column), 즉 데이터의 속성을 의미한다.
```
CharField, IntegerField, BooleanField, DateField, DateTimeField, EmailField, FileField, ImageField
``` 
등등이 있다.

- 옵션은 모든 필드 타입에 사용할 수 있으며 선택적으로 적용할 수 있다.

#### 마이그레이션

- 마이그레이션은 django의 데이터베이스 변경사항에 대한 저장 시스템인데, 쉽게 말해 변경사항을 저장해둔 버전 관리를 위한 목록이다. makemigrations와 migrate을 하고 나면 0001_inital.py 와 같은 형태로 1번 migration이 생기는데 내부를 대충 둘러보면 **id**값이 저장되어 있다. id는 장고에서 자동으로 생성해주는 필드로, 각각의 menu 데이터를 구분하기 위한 고유값이다. 

- python code -> model(ORM) -> database

#### CRUD

- 대부분의 데이터베이스를 관리하는 기능을 의미한다. Create, Read, Update, Delete 를 줄여서 부르는 약칭으로 CRUD라고 부른다.

#### QuerySet

- django의 ORM을 이용해서 데이터베이스와 소통할때 발생하는 것으로 자료형의 리스트와 비슷하다. ORM을 통해 조회한 데이터베이스를 QuerySet을 통해서 파이썬 코드로 조회/가공할 수 있다.

#### 하드코딩(HardCoding)

- 소스코드안에 데이터가 직접 입력되어 있는 코딩형태인 *하드코딩*을 우리는 지양해야 한다.

#### Django 배포

- Django를 배포하는 것에는 크게 두가지 방법이 있다. 
